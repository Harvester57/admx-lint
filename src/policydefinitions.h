// Copyright (c) 2005-2017 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from PolicyDefinitions.xsd.
 */

#ifndef POLICY_DEFINITIONS_H
#define POLICY_DEFINITIONS_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4009911L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type Type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type Container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char Byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char UnsignedByte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short Short;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short UnsignedShort;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int Int;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int UnsignedInt;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long Long;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long UnsignedLong;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long Integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long NonPositiveInteger;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long NonNegativeInteger;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long PositiveInteger;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long NegativeInteger;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool Boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float Float;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double Double;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double Decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, Token > Name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, Token > Language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > Buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone TimeZone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;



  /**
   * @brief Content order sequence entry.
   */
  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags Flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity Severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > Error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > Exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > Bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > Parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;

  /**
   * @brief Exception indicating that the type information
   * is not available for a type.
   */
  typedef ::xsd::cxx::tree::no_type_info< char > NoTypeInfo;

  /**
   * @brief Exception indicating that the types are not
   * related by inheritance.
   */
  typedef ::xsd::cxx::tree::not_derived< char > NotDerived;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace GroupPolicy
{
  namespace PolicyDefinitions
  {
    class DecimalElement;
    class LongDecimalElement;
    class BooleanElement;
    class TextElement;
    class EnumerationElement;
    class ListElement;
    class Value;
    class ValueList;
    class ValueItem;
    class MultiTextElement;
    class DataElementContent;
    class DataElement;
    class DecimalTextBox;
    class LongDecimalTextBox;
    class TextBox;
    class MultiTextBox;
    class CheckBox;
    class ComboBox;
    class DropdownList;
    class ListBox;
    class PolicyPresentation;
    class CategoryReference;
    class Category;
    class SupportedProducts;
    class SupportedProduct;
    class SupportedMajorVersion;
    class SupportedMinorVersion;
    class SupportedOnReference;
    class SupportedOnRange;
    class SupportedAndCondition;
    class SupportedOrCondition;
    class SupportedOnDefinition;
    class SupportedOnDefinitions;
    class PolicyClass;
    class PolicyDefinition;
    class PolicyElements;
    class Item;
    class Delete;
    class Decimal;
    class LongDecimal;
    class String;
  }
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>
#include <xsd/cxx/tree/containers-wildcard.hxx>

#include "basetypes.h"

namespace GroupPolicy
{
  /**
   * @brief C++ namespace for the %http://www.microsoft.com/GroupPolicy/PolicyDefinitions
   * schema namespace.
   */
  namespace PolicyDefinitions
  {
    /**
     * @brief Class corresponding to the %DecimalElement schema type.
     *
     * Describes a number/decimal element in a
     * policy
     *
     * @nosubgrouping
     */
    class DecimalElement: public ::xml_schema::Type
    {
      public:
      /**
       * @name id
       *
       * @brief Accessor and modifier functions for the %id
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::String IdType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const IdType&
      id () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      IdType&
      id ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      id (const IdType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      id (::std::unique_ptr< IdType > p);

      //@}

      /**
       * @name clientExtension
       *
       * @brief Accessor and modifier functions for the %clientExtension
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::GUID ClientExtensionType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ClientExtensionType > ClientExtensionOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ClientExtensionType, char > ClientExtensionTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ClientExtensionOptional&
      clientExtension () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ClientExtensionOptional&
      clientExtension ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      clientExtension (const ClientExtensionType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      clientExtension (const ClientExtensionOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      clientExtension (::std::unique_ptr< ClientExtensionType > p);

      //@}

      /**
       * @name key
       *
       * @brief Accessor and modifier functions for the %key
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryKey KeyType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< KeyType > KeyOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< KeyType, char > KeyTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const KeyOptional&
      key () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      KeyOptional&
      key ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      key (const KeyType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      key (const KeyOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      key (::std::unique_ptr< KeyType > p);

      //@}

      /**
       * @name valueName
       *
       * @brief Accessor and modifier functions for the %valueName
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryValueName ValueNameType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ValueNameType > ValueNameOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ValueNameType, char > ValueNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ValueNameOptional&
      valueName () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ValueNameOptional&
      valueName ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      valueName (const ValueNameType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      valueName (const ValueNameOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      valueName (::std::unique_ptr< ValueNameType > p);

      //@}

      /**
       * @name required
       *
       * @brief Accessor and modifier functions for the %required
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean RequiredType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< RequiredType, char > RequiredTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const RequiredType&
      required () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      RequiredType&
      required ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      required (const RequiredType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static RequiredType
      required_default_value ();

      //@}

      /**
       * @name minValue
       *
       * @brief Accessor and modifier functions for the %minValue
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt MinValueType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< MinValueType, char > MinValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const MinValueType&
      minValue () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      MinValueType&
      minValue ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      minValue (const MinValueType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static MinValueType
      minValue_default_value ();

      //@}

      /**
       * @name maxValue
       *
       * @brief Accessor and modifier functions for the %maxValue
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt MaxValueType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< MaxValueType, char > MaxValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const MaxValueType&
      maxValue () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      MaxValueType&
      maxValue ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      maxValue (const MaxValueType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static MaxValueType
      maxValue_default_value ();

      //@}

      /**
       * @name storeAsText
       *
       * @brief Accessor and modifier functions for the %storeAsText
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean StoreAsTextType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< StoreAsTextType, char > StoreAsTextTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const StoreAsTextType&
      storeAsText () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      StoreAsTextType&
      storeAsText ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      storeAsText (const StoreAsTextType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static StoreAsTextType
      storeAsText_default_value ();

      //@}

      /**
       * @name soft
       *
       * @brief Accessor and modifier functions for the %soft
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean SoftType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< SoftType, char > SoftTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const SoftType&
      soft () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      SoftType&
      soft ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      soft (const SoftType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static SoftType
      soft_default_value ();

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      DecimalElement (const IdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DecimalElement (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DecimalElement (const DecimalElement& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual DecimalElement*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DecimalElement&
      operator= (const DecimalElement& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~DecimalElement ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< IdType > id_;
      ClientExtensionOptional clientExtension_;
      KeyOptional key_;
      ValueNameOptional valueName_;
      ::xsd::cxx::tree::one< RequiredType > required_;
      ::xsd::cxx::tree::one< MinValueType > minValue_;
      ::xsd::cxx::tree::one< MaxValueType > maxValue_;
      ::xsd::cxx::tree::one< StoreAsTextType > storeAsText_;
      ::xsd::cxx::tree::one< SoftType > soft_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %LongDecimalElement schema type.
     *
     * Describes a QWORD number/decimal element in a policy
     *
     * @nosubgrouping
     */
    class LongDecimalElement: public ::xml_schema::Type
    {
      public:
      /**
       * @name id
       *
       * @brief Accessor and modifier functions for the %id
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::String IdType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const IdType&
      id () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      IdType&
      id ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      id (const IdType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      id (::std::unique_ptr< IdType > p);

      //@}

      /**
       * @name clientExtension
       *
       * @brief Accessor and modifier functions for the %clientExtension
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::GUID ClientExtensionType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ClientExtensionType > ClientExtensionOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ClientExtensionType, char > ClientExtensionTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ClientExtensionOptional&
      clientExtension () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ClientExtensionOptional&
      clientExtension ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      clientExtension (const ClientExtensionType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      clientExtension (const ClientExtensionOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      clientExtension (::std::unique_ptr< ClientExtensionType > p);

      //@}

      /**
       * @name key
       *
       * @brief Accessor and modifier functions for the %key
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryKey KeyType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< KeyType > KeyOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< KeyType, char > KeyTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const KeyOptional&
      key () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      KeyOptional&
      key ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      key (const KeyType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      key (const KeyOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      key (::std::unique_ptr< KeyType > p);

      //@}

      /**
       * @name valueName
       *
       * @brief Accessor and modifier functions for the %valueName
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryValueName ValueNameType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ValueNameType > ValueNameOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ValueNameType, char > ValueNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ValueNameOptional&
      valueName () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ValueNameOptional&
      valueName ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      valueName (const ValueNameType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      valueName (const ValueNameOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      valueName (::std::unique_ptr< ValueNameType > p);

      //@}

      /**
       * @name required
       *
       * @brief Accessor and modifier functions for the %required
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean RequiredType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< RequiredType, char > RequiredTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const RequiredType&
      required () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      RequiredType&
      required ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      required (const RequiredType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static RequiredType
      required_default_value ();

      //@}

      /**
       * @name minValue
       *
       * @brief Accessor and modifier functions for the %minValue
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedLong MinValueType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< MinValueType, char > MinValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const MinValueType&
      minValue () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      MinValueType&
      minValue ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      minValue (const MinValueType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static MinValueType
      minValue_default_value ();

      //@}

      /**
       * @name maxValue
       *
       * @brief Accessor and modifier functions for the %maxValue
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedLong MaxValueType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< MaxValueType, char > MaxValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const MaxValueType&
      maxValue () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      MaxValueType&
      maxValue ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      maxValue (const MaxValueType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static MaxValueType
      maxValue_default_value ();

      //@}

      /**
       * @name storeAsText
       *
       * @brief Accessor and modifier functions for the %storeAsText
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean StoreAsTextType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< StoreAsTextType, char > StoreAsTextTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const StoreAsTextType&
      storeAsText () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      StoreAsTextType&
      storeAsText ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      storeAsText (const StoreAsTextType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static StoreAsTextType
      storeAsText_default_value ();

      //@}

      /**
       * @name soft
       *
       * @brief Accessor and modifier functions for the %soft
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean SoftType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< SoftType, char > SoftTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const SoftType&
      soft () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      SoftType&
      soft ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      soft (const SoftType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static SoftType
      soft_default_value ();

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      LongDecimalElement (const IdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      LongDecimalElement (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      LongDecimalElement (const LongDecimalElement& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual LongDecimalElement*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      LongDecimalElement&
      operator= (const LongDecimalElement& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~LongDecimalElement ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< IdType > id_;
      ClientExtensionOptional clientExtension_;
      KeyOptional key_;
      ValueNameOptional valueName_;
      ::xsd::cxx::tree::one< RequiredType > required_;
      ::xsd::cxx::tree::one< MinValueType > minValue_;
      ::xsd::cxx::tree::one< MaxValueType > maxValue_;
      ::xsd::cxx::tree::one< StoreAsTextType > storeAsText_;
      ::xsd::cxx::tree::one< SoftType > soft_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %BooleanElement schema type.
     *
     * Describes a choice element in a policy with associated values for the
     * true and false cases.
     *
     * @nosubgrouping
     */
    class BooleanElement: public ::xml_schema::Type
    {
      public:
      /**
       * @name trueValue
       *
       * @brief Accessor and modifier functions for the %trueValue
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::Value TrueValueType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< TrueValueType > TrueValueOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TrueValueType, char > TrueValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const TrueValueOptional&
      trueValue () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      TrueValueOptional&
      trueValue ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      trueValue (const TrueValueType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      trueValue (const TrueValueOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      trueValue (::std::unique_ptr< TrueValueType > p);

      //@}

      /**
       * @name falseValue
       *
       * @brief Accessor and modifier functions for the %falseValue
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::Value FalseValueType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< FalseValueType > FalseValueOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< FalseValueType, char > FalseValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const FalseValueOptional&
      falseValue () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      FalseValueOptional&
      falseValue ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      falseValue (const FalseValueType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      falseValue (const FalseValueOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      falseValue (::std::unique_ptr< FalseValueType > p);

      //@}

      /**
       * @name trueList
       *
       * @brief Accessor and modifier functions for the %trueList
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ValueList TrueListType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< TrueListType > TrueListOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TrueListType, char > TrueListTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const TrueListOptional&
      trueList () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      TrueListOptional&
      trueList ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      trueList (const TrueListType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      trueList (const TrueListOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      trueList (::std::unique_ptr< TrueListType > p);

      //@}

      /**
       * @name falseList
       *
       * @brief Accessor and modifier functions for the %falseList
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ValueList FalseListType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< FalseListType > FalseListOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< FalseListType, char > FalseListTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const FalseListOptional&
      falseList () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      FalseListOptional&
      falseList ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      falseList (const FalseListType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      falseList (const FalseListOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      falseList (::std::unique_ptr< FalseListType > p);

      //@}

      /**
       * @name id
       *
       * @brief Accessor and modifier functions for the %id
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::String IdType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const IdType&
      id () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      IdType&
      id ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      id (const IdType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      id (::std::unique_ptr< IdType > p);

      //@}

      /**
       * @name clientExtension
       *
       * @brief Accessor and modifier functions for the %clientExtension
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::GUID ClientExtensionType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ClientExtensionType > ClientExtensionOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ClientExtensionType, char > ClientExtensionTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ClientExtensionOptional&
      clientExtension () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ClientExtensionOptional&
      clientExtension ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      clientExtension (const ClientExtensionType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      clientExtension (const ClientExtensionOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      clientExtension (::std::unique_ptr< ClientExtensionType > p);

      //@}

      /**
       * @name key
       *
       * @brief Accessor and modifier functions for the %key
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryKey KeyType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< KeyType > KeyOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< KeyType, char > KeyTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const KeyOptional&
      key () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      KeyOptional&
      key ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      key (const KeyType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      key (const KeyOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      key (::std::unique_ptr< KeyType > p);

      //@}

      /**
       * @name valueName
       *
       * @brief Accessor and modifier functions for the %valueName
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryValueName ValueNameType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ValueNameType > ValueNameOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ValueNameType, char > ValueNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ValueNameOptional&
      valueName () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ValueNameOptional&
      valueName ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      valueName (const ValueNameType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      valueName (const ValueNameOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      valueName (::std::unique_ptr< ValueNameType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      BooleanElement (const IdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      BooleanElement (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      BooleanElement (const BooleanElement& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual BooleanElement*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      BooleanElement&
      operator= (const BooleanElement& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~BooleanElement ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      TrueValueOptional trueValue_;
      FalseValueOptional falseValue_;
      TrueListOptional trueList_;
      FalseListOptional falseList_;
      ::xsd::cxx::tree::one< IdType > id_;
      ClientExtensionOptional clientExtension_;
      KeyOptional key_;
      ValueNameOptional valueName_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %TextElement schema type.
     *
     * Describes a text element in a policy.
     *
     * @nosubgrouping
     */
    class TextElement: public ::xml_schema::Type
    {
      public:
      /**
       * @name id
       *
       * @brief Accessor and modifier functions for the %id
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::String IdType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const IdType&
      id () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      IdType&
      id ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      id (const IdType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      id (::std::unique_ptr< IdType > p);

      //@}

      /**
       * @name clientExtension
       *
       * @brief Accessor and modifier functions for the %clientExtension
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::GUID ClientExtensionType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ClientExtensionType > ClientExtensionOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ClientExtensionType, char > ClientExtensionTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ClientExtensionOptional&
      clientExtension () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ClientExtensionOptional&
      clientExtension ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      clientExtension (const ClientExtensionType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      clientExtension (const ClientExtensionOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      clientExtension (::std::unique_ptr< ClientExtensionType > p);

      //@}

      /**
       * @name key
       *
       * @brief Accessor and modifier functions for the %key
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryKey KeyType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< KeyType > KeyOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< KeyType, char > KeyTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const KeyOptional&
      key () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      KeyOptional&
      key ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      key (const KeyType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      key (const KeyOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      key (::std::unique_ptr< KeyType > p);

      //@}

      /**
       * @name valueName
       *
       * @brief Accessor and modifier functions for the %valueName
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryValueName ValueNameType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ValueNameType > ValueNameOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ValueNameType, char > ValueNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ValueNameOptional&
      valueName () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ValueNameOptional&
      valueName ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      valueName (const ValueNameType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      valueName (const ValueNameOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      valueName (::std::unique_ptr< ValueNameType > p);

      //@}

      /**
       * @name required
       *
       * @brief Accessor and modifier functions for the %required
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean RequiredType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< RequiredType, char > RequiredTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const RequiredType&
      required () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      RequiredType&
      required ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      required (const RequiredType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static RequiredType
      required_default_value ();

      //@}

      /**
       * @name maxLength
       *
       * @brief Accessor and modifier functions for the %maxLength
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt MaxLengthType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< MaxLengthType, char > MaxLengthTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const MaxLengthType&
      maxLength () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      MaxLengthType&
      maxLength ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      maxLength (const MaxLengthType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static MaxLengthType
      maxLength_default_value ();

      //@}

      /**
       * @name expandable
       *
       * @brief Accessor and modifier functions for the %expandable
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean ExpandableType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ExpandableType, char > ExpandableTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const ExpandableType&
      expandable () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      ExpandableType&
      expandable ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      expandable (const ExpandableType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static ExpandableType
      expandable_default_value ();

      //@}

      /**
       * @name soft
       *
       * @brief Accessor and modifier functions for the %soft
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean SoftType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< SoftType, char > SoftTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const SoftType&
      soft () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      SoftType&
      soft ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      soft (const SoftType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static SoftType
      soft_default_value ();

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      TextElement (const IdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      TextElement (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      TextElement (const TextElement& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual TextElement*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      TextElement&
      operator= (const TextElement& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~TextElement ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< IdType > id_;
      ClientExtensionOptional clientExtension_;
      KeyOptional key_;
      ValueNameOptional valueName_;
      ::xsd::cxx::tree::one< RequiredType > required_;
      ::xsd::cxx::tree::one< MaxLengthType > maxLength_;
      ::xsd::cxx::tree::one< ExpandableType > expandable_;
      ::xsd::cxx::tree::one< SoftType > soft_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %EnumerationElement schema type.
     *
     * Describes an enumeration element in a policy.
     *
     * @nosubgrouping
     */
    class EnumerationElement: public ::xml_schema::Type
    {
      public:
      /**
       * @name item
       *
       * @brief Accessor and modifier functions for the %item
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::Item ItemType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ItemType > ItemSequence;

      /**
       * @brief Element iterator type.
       */
      typedef ItemSequence::iterator ItemIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ItemSequence::const_iterator ItemConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ItemType, char > ItemTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ItemSequence&
      item () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ItemSequence&
      item ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      item (const ItemSequence& s);

      //@}

      /**
       * @name id
       *
       * @brief Accessor and modifier functions for the %id
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::String IdType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const IdType&
      id () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      IdType&
      id ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      id (const IdType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      id (::std::unique_ptr< IdType > p);

      //@}

      /**
       * @name clientExtension
       *
       * @brief Accessor and modifier functions for the %clientExtension
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::GUID ClientExtensionType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ClientExtensionType > ClientExtensionOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ClientExtensionType, char > ClientExtensionTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ClientExtensionOptional&
      clientExtension () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ClientExtensionOptional&
      clientExtension ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      clientExtension (const ClientExtensionType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      clientExtension (const ClientExtensionOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      clientExtension (::std::unique_ptr< ClientExtensionType > p);

      //@}

      /**
       * @name key
       *
       * @brief Accessor and modifier functions for the %key
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryKey KeyType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< KeyType > KeyOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< KeyType, char > KeyTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const KeyOptional&
      key () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      KeyOptional&
      key ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      key (const KeyType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      key (const KeyOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      key (::std::unique_ptr< KeyType > p);

      //@}

      /**
       * @name valueName
       *
       * @brief Accessor and modifier functions for the %valueName
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryValueName ValueNameType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ValueNameType > ValueNameOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ValueNameType, char > ValueNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ValueNameOptional&
      valueName () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ValueNameOptional&
      valueName ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      valueName (const ValueNameType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      valueName (const ValueNameOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      valueName (::std::unique_ptr< ValueNameType > p);

      //@}

      /**
       * @name required
       *
       * @brief Accessor and modifier functions for the %required
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean RequiredType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< RequiredType, char > RequiredTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const RequiredType&
      required () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      RequiredType&
      required ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      required (const RequiredType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static RequiredType
      required_default_value ();

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      EnumerationElement (const IdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      EnumerationElement (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      EnumerationElement (const EnumerationElement& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual EnumerationElement*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      EnumerationElement&
      operator= (const EnumerationElement& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~EnumerationElement ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ItemSequence item_;
      ::xsd::cxx::tree::one< IdType > id_;
      ClientExtensionOptional clientExtension_;
      KeyOptional key_;
      ValueNameOptional valueName_;
      ::xsd::cxx::tree::one< RequiredType > required_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ListElement schema type.
     *
     * Describes a list element in a policy.
     *
     * @nosubgrouping
     */
    class ListElement: public ::xml_schema::Type
    {
      public:
      /**
       * @name id
       *
       * @brief Accessor and modifier functions for the %id
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::String IdType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const IdType&
      id () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      IdType&
      id ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      id (const IdType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      id (::std::unique_ptr< IdType > p);

      //@}

      /**
       * @name clientExtension
       *
       * @brief Accessor and modifier functions for the %clientExtension
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::GUID ClientExtensionType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ClientExtensionType > ClientExtensionOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ClientExtensionType, char > ClientExtensionTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ClientExtensionOptional&
      clientExtension () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ClientExtensionOptional&
      clientExtension ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      clientExtension (const ClientExtensionType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      clientExtension (const ClientExtensionOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      clientExtension (::std::unique_ptr< ClientExtensionType > p);

      //@}

      /**
       * @name key
       *
       * @brief Accessor and modifier functions for the %key
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryKey KeyType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< KeyType > KeyOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< KeyType, char > KeyTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const KeyOptional&
      key () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      KeyOptional&
      key ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      key (const KeyType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      key (const KeyOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      key (::std::unique_ptr< KeyType > p);

      //@}

      /**
       * @name valuePrefix
       *
       * @brief Accessor and modifier functions for the %valuePrefix
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::String ValuePrefixType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ValuePrefixType > ValuePrefixOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ValuePrefixType, char > ValuePrefixTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ValuePrefixOptional&
      valuePrefix () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ValuePrefixOptional&
      valuePrefix ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      valuePrefix (const ValuePrefixType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      valuePrefix (const ValuePrefixOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      valuePrefix (::std::unique_ptr< ValuePrefixType > p);

      //@}

      /**
       * @name additive
       *
       * @brief Accessor and modifier functions for the %additive
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean AdditiveType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< AdditiveType, char > AdditiveTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const AdditiveType&
      additive () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      AdditiveType&
      additive ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      additive (const AdditiveType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static AdditiveType
      additive_default_value ();

      //@}

      /**
       * @name expandable
       *
       * @brief Accessor and modifier functions for the %expandable
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean ExpandableType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ExpandableType, char > ExpandableTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const ExpandableType&
      expandable () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      ExpandableType&
      expandable ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      expandable (const ExpandableType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static ExpandableType
      expandable_default_value ();

      //@}

      /**
       * @name explicitValue
       *
       * @brief Accessor and modifier functions for the %explicitValue
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean ExplicitValueType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ExplicitValueType, char > ExplicitValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const ExplicitValueType&
      explicitValue () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      ExplicitValueType&
      explicitValue ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      explicitValue (const ExplicitValueType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static ExplicitValueType
      explicitValue_default_value ();

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ListElement (const IdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ListElement (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ListElement (const ListElement& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ListElement*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ListElement&
      operator= (const ListElement& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ListElement ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< IdType > id_;
      ClientExtensionOptional clientExtension_;
      KeyOptional key_;
      ValuePrefixOptional valuePrefix_;
      ::xsd::cxx::tree::one< AdditiveType > additive_;
      ::xsd::cxx::tree::one< ExpandableType > expandable_;
      ::xsd::cxx::tree::one< ExplicitValueType > explicitValue_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %Value schema type.
     *
     * @nosubgrouping
     */
    class Value: public ::xml_schema::Type
    {
      public:
      /**
       * @name delete
       *
       * @brief Accessor and modifier functions for the %delete
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::Delete DeleteType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< DeleteType > DeleteOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< DeleteType, char > DeleteTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const DeleteOptional&
      delete_ () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      DeleteOptional&
      delete_ ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      delete_ (const DeleteType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      delete_ (const DeleteOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      delete_ (::std::unique_ptr< DeleteType > p);

      //@}

      /**
       * @name decimal
       *
       * @brief Accessor and modifier functions for the %decimal
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::Decimal DecimalType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< DecimalType > DecimalOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< DecimalType, char > DecimalTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const DecimalOptional&
      decimal () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      DecimalOptional&
      decimal ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      decimal (const DecimalType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      decimal (const DecimalOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      decimal (::std::unique_ptr< DecimalType > p);

      //@}

      /**
       * @name longDecimal
       *
       * @brief Accessor and modifier functions for the %longDecimal
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::LongDecimal LongDecimalType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< LongDecimalType > LongDecimalOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< LongDecimalType, char > LongDecimalTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const LongDecimalOptional&
      longDecimal () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      LongDecimalOptional&
      longDecimal ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      longDecimal (const LongDecimalType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      longDecimal (const LongDecimalOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      longDecimal (::std::unique_ptr< LongDecimalType > p);

      //@}

      /**
       * @name string
       *
       * @brief Accessor and modifier functions for the %string
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::String StringType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< StringType > StringOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< StringType, char > StringTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const StringOptional&
      string () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      StringOptional&
      string ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      string (const StringType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      string (const StringOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      string (::std::unique_ptr< StringType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      Value ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      Value (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Value (const Value& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual Value*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Value&
      operator= (const Value& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~Value ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      DeleteOptional delete__;
      DecimalOptional decimal_;
      LongDecimalOptional longDecimal_;
      StringOptional string_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ValueList schema type.
     *
     * @nosubgrouping
     */
    class ValueList: public ::xml_schema::Type
    {
      public:
      /**
       * @name item
       *
       * @brief Accessor and modifier functions for the %item
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ValueItem ItemType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ItemType > ItemSequence;

      /**
       * @brief Element iterator type.
       */
      typedef ItemSequence::iterator ItemIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ItemSequence::const_iterator ItemConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ItemType, char > ItemTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ItemSequence&
      item () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ItemSequence&
      item ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      item (const ItemSequence& s);

      //@}

      /**
       * @name defaultKey
       *
       * @brief Accessor and modifier functions for the %defaultKey
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryKey DefaultKeyType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< DefaultKeyType > DefaultKeyOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< DefaultKeyType, char > DefaultKeyTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const DefaultKeyOptional&
      defaultKey () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      DefaultKeyOptional&
      defaultKey ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      defaultKey (const DefaultKeyType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      defaultKey (const DefaultKeyOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      defaultKey (::std::unique_ptr< DefaultKeyType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ValueList ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ValueList (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ValueList (const ValueList& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ValueList*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ValueList&
      operator= (const ValueList& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ValueList ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ItemSequence item_;
      DefaultKeyOptional defaultKey_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ValueItem schema type.
     *
     * @nosubgrouping
     */
    class ValueItem: public ::xml_schema::Type
    {
      public:
      /**
       * @name value
       *
       * @brief Accessor and modifier functions for the %value
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::Value ValueType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const ValueType&
      value () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      ValueType&
      value ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      value (const ValueType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      value (::std::unique_ptr< ValueType > p);

      //@}

      /**
       * @name key
       *
       * @brief Accessor and modifier functions for the %key
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryKey KeyType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< KeyType > KeyOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< KeyType, char > KeyTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const KeyOptional&
      key () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      KeyOptional&
      key ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      key (const KeyType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      key (const KeyOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      key (::std::unique_ptr< KeyType > p);

      //@}

      /**
       * @name valueName
       *
       * @brief Accessor and modifier functions for the %valueName
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryValueName ValueNameType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ValueNameType, char > ValueNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const ValueNameType&
      valueName () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      ValueNameType&
      valueName ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      valueName (const ValueNameType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      valueName (::std::unique_ptr< ValueNameType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ValueItem (const ValueType&,
                 const ValueNameType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      ValueItem (::std::unique_ptr< ValueType >,
                 const ValueNameType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ValueItem (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ValueItem (const ValueItem& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ValueItem*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ValueItem&
      operator= (const ValueItem& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ValueItem ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< ValueType > value_;
      KeyOptional key_;
      ::xsd::cxx::tree::one< ValueNameType > valueName_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %multiTextElement schema type.
     *
     * Describes a multi line text element in a policy
     *
     * @nosubgrouping
     */
    class MultiTextElement: public ::xml_schema::Type
    {
      public:
      /**
       * @name id
       *
       * @brief Accessor and modifier functions for the %id
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::String IdType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const IdType&
      id () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      IdType&
      id ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      id (const IdType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      id (::std::unique_ptr< IdType > p);

      //@}

      /**
       * @name clientExtension
       *
       * @brief Accessor and modifier functions for the %clientExtension
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::GUID ClientExtensionType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ClientExtensionType > ClientExtensionOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ClientExtensionType, char > ClientExtensionTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ClientExtensionOptional&
      clientExtension () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ClientExtensionOptional&
      clientExtension ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      clientExtension (const ClientExtensionType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      clientExtension (const ClientExtensionOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      clientExtension (::std::unique_ptr< ClientExtensionType > p);

      //@}

      /**
       * @name key
       *
       * @brief Accessor and modifier functions for the %key
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryKey KeyType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< KeyType > KeyOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< KeyType, char > KeyTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const KeyOptional&
      key () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      KeyOptional&
      key ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      key (const KeyType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      key (const KeyOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      key (::std::unique_ptr< KeyType > p);

      //@}

      /**
       * @name valueName
       *
       * @brief Accessor and modifier functions for the %valueName
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryValueName ValueNameType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ValueNameType > ValueNameOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ValueNameType, char > ValueNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ValueNameOptional&
      valueName () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ValueNameOptional&
      valueName ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      valueName (const ValueNameType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      valueName (const ValueNameOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      valueName (::std::unique_ptr< ValueNameType > p);

      //@}

      /**
       * @name required
       *
       * @brief Accessor and modifier functions for the %required
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean RequiredType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< RequiredType, char > RequiredTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const RequiredType&
      required () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      RequiredType&
      required ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      required (const RequiredType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static RequiredType
      required_default_value ();

      //@}

      /**
       * @name maxLength
       *
       * @brief Accessor and modifier functions for the %maxLength
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt MaxLengthType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< MaxLengthType, char > MaxLengthTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const MaxLengthType&
      maxLength () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      MaxLengthType&
      maxLength ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      maxLength (const MaxLengthType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static MaxLengthType
      maxLength_default_value ();

      //@}

      /**
       * @name maxStrings
       *
       * @brief Accessor and modifier functions for the %maxStrings
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt MaxStringsType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< MaxStringsType, char > MaxStringsTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const MaxStringsType&
      maxStrings () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      MaxStringsType&
      maxStrings ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      maxStrings (const MaxStringsType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static MaxStringsType
      maxStrings_default_value ();

      //@}

      /**
       * @name soft
       *
       * @brief Accessor and modifier functions for the %soft
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean SoftType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< SoftType, char > SoftTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const SoftType&
      soft () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      SoftType&
      soft ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      soft (const SoftType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static SoftType
      soft_default_value ();

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      MultiTextElement (const IdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      MultiTextElement (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      MultiTextElement (const MultiTextElement& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual MultiTextElement*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      MultiTextElement&
      operator= (const MultiTextElement& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~MultiTextElement ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< IdType > id_;
      ClientExtensionOptional clientExtension_;
      KeyOptional key_;
      ValueNameOptional valueName_;
      ::xsd::cxx::tree::one< RequiredType > required_;
      ::xsd::cxx::tree::one< MaxLengthType > maxLength_;
      ::xsd::cxx::tree::one< MaxStringsType > maxStrings_;
      ::xsd::cxx::tree::one< SoftType > soft_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %DataElementContent schema type.
     *
     * @nosubgrouping
     */
    class DataElementContent: public ::xml_schema::String
    {
      public:
      /**
       * @name refId
       *
       * @brief Accessor and modifier functions for the %refId
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::String RefIdType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< RefIdType, char > RefIdTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const RefIdType&
      refId () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      RefIdType&
      refId ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      refId (const RefIdType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      refId (::std::unique_ptr< RefIdType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from initializers for required 
       * elements and attributes.
       */
      DataElementContent (const RefIdType&);

      /**
       * @brief Create an instance from a C string and initializers
       * for required elements and attributes.
       */
      DataElementContent (const char*,
                          const RefIdType&);

      /**
       * @brief Create an instance from a string andinitializers
       * for required elements and attributes.
       */
      DataElementContent (const ::std::string&,
                          const RefIdType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      DataElementContent (const ::xml_schema::String&,
                          const RefIdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DataElementContent (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DataElementContent (const DataElementContent& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual DataElementContent*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const = 0;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DataElementContent&
      operator= (const DataElementContent& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~DataElementContent ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< RefIdType > refId_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %DataElement schema type.
     *
     * @nosubgrouping
     */
    class DataElement: public ::xml_schema::Type
    {
      public:
      /**
       * @name refId
       *
       * @brief Accessor and modifier functions for the %refId
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::String RefIdType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< RefIdType, char > RefIdTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const RefIdType&
      refId () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      RefIdType&
      refId ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      refId (const RefIdType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      refId (::std::unique_ptr< RefIdType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      DataElement (const RefIdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DataElement (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DataElement (const DataElement& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual DataElement*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const = 0;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DataElement&
      operator= (const DataElement& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~DataElement ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< RefIdType > refId_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %DecimalTextBox schema type.
     *
     * Represents a text box with or without a spin control for entering
     * decimal numbers.
     *
     * @nosubgrouping
     */
    class DecimalTextBox: public ::GroupPolicy::PolicyDefinitions::DataElementContent
    {
      public:
      /**
       * @name defaultValue
       *
       * @brief Accessor and modifier functions for the %defaultValue
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt DefaultValueType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< DefaultValueType, char > DefaultValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const DefaultValueType&
      defaultValue () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      DefaultValueType&
      defaultValue ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      defaultValue (const DefaultValueType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static DefaultValueType
      defaultValue_default_value ();

      //@}

      /**
       * @name spin
       *
       * @brief Accessor and modifier functions for the %spin
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean SpinType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< SpinType, char > SpinTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const SpinType&
      spin () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      SpinType&
      spin ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      spin (const SpinType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static SpinType
      spin_default_value ();

      //@}

      /**
       * @name spinStep
       *
       * @brief Accessor and modifier functions for the %spinStep
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt SpinStepType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< SpinStepType, char > SpinStepTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const SpinStepType&
      spinStep () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      SpinStepType&
      spinStep ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      spinStep (const SpinStepType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static SpinStepType
      spinStep_default_value ();

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from initializers for required 
       * elements and attributes.
       */
      DecimalTextBox (const RefIdType&);

      /**
       * @brief Create an instance from a C string and initializers
       * for required elements and attributes.
       */
      DecimalTextBox (const char*,
                      const RefIdType&);

      /**
       * @brief Create an instance from a string andinitializers
       * for required elements and attributes.
       */
      DecimalTextBox (const ::std::string&,
                      const RefIdType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      DecimalTextBox (const ::xml_schema::String&,
                      const RefIdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DecimalTextBox (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DecimalTextBox (const DecimalTextBox& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual DecimalTextBox*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DecimalTextBox&
      operator= (const DecimalTextBox& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~DecimalTextBox ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< DefaultValueType > defaultValue_;
      ::xsd::cxx::tree::one< SpinType > spin_;
      ::xsd::cxx::tree::one< SpinStepType > spinStep_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %LongDecimalTextBox schema type.
     *
     * Represents a text box with or without a spin control for entering
     * 64-bit decimal numbers.
     *
     * @nosubgrouping
     */
    class LongDecimalTextBox: public ::GroupPolicy::PolicyDefinitions::DataElementContent
    {
      public:
      /**
       * @name defaultValue
       *
       * @brief Accessor and modifier functions for the %defaultValue
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt DefaultValueType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< DefaultValueType, char > DefaultValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const DefaultValueType&
      defaultValue () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      DefaultValueType&
      defaultValue ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      defaultValue (const DefaultValueType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static DefaultValueType
      defaultValue_default_value ();

      //@}

      /**
       * @name spin
       *
       * @brief Accessor and modifier functions for the %spin
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean SpinType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< SpinType, char > SpinTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const SpinType&
      spin () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      SpinType&
      spin ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      spin (const SpinType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static SpinType
      spin_default_value ();

      //@}

      /**
       * @name spinStep
       *
       * @brief Accessor and modifier functions for the %spinStep
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt SpinStepType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< SpinStepType, char > SpinStepTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const SpinStepType&
      spinStep () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      SpinStepType&
      spinStep ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      spinStep (const SpinStepType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static SpinStepType
      spinStep_default_value ();

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from initializers for required 
       * elements and attributes.
       */
      LongDecimalTextBox (const RefIdType&);

      /**
       * @brief Create an instance from a C string and initializers
       * for required elements and attributes.
       */
      LongDecimalTextBox (const char*,
                          const RefIdType&);

      /**
       * @brief Create an instance from a string andinitializers
       * for required elements and attributes.
       */
      LongDecimalTextBox (const ::std::string&,
                          const RefIdType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      LongDecimalTextBox (const ::xml_schema::String&,
                          const RefIdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      LongDecimalTextBox (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      LongDecimalTextBox (const LongDecimalTextBox& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual LongDecimalTextBox*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      LongDecimalTextBox&
      operator= (const LongDecimalTextBox& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~LongDecimalTextBox ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< DefaultValueType > defaultValue_;
      ::xsd::cxx::tree::one< SpinType > spin_;
      ::xsd::cxx::tree::one< SpinStepType > spinStep_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %TextBox schema type.
     *
     * Represents a textbox display element.
     *
     * @nosubgrouping
     */
    class TextBox: public ::GroupPolicy::PolicyDefinitions::DataElement
    {
      public:
      /**
       * @name label
       *
       * @brief Accessor and modifier functions for the %label
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String LabelType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< LabelType, char > LabelTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const LabelType&
      label () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      LabelType&
      label ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      label (const LabelType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      label (::std::unique_ptr< LabelType > p);

      //@}

      /**
       * @name defaultValue
       *
       * @brief Accessor and modifier functions for the %defaultValue
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String DefaultValueType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< DefaultValueType > DefaultValueOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< DefaultValueType, char > DefaultValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const DefaultValueOptional&
      defaultValue () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      DefaultValueOptional&
      defaultValue ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      defaultValue (const DefaultValueType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      defaultValue (const DefaultValueOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      defaultValue (::std::unique_ptr< DefaultValueType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      TextBox (const RefIdType&,
               const LabelType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      TextBox (const RefIdType&,
               ::std::unique_ptr< LabelType >);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      TextBox (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      TextBox (const TextBox& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual TextBox*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      TextBox&
      operator= (const TextBox& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~TextBox ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< LabelType > label_;
      DefaultValueOptional defaultValue_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %MultiTextBox schema type.
     *
     * Represents a multi-line textbox display element.
     *
     * @nosubgrouping
     */
    class MultiTextBox: public ::GroupPolicy::PolicyDefinitions::DataElement
    {
      public:
      /**
       * @name showAsDialog
       *
       * @brief Accessor and modifier functions for the %showAsDialog
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean ShowAsDialogType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ShowAsDialogType, char > ShowAsDialogTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const ShowAsDialogType&
      showAsDialog () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      ShowAsDialogType&
      showAsDialog ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      showAsDialog (const ShowAsDialogType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static ShowAsDialogType
      showAsDialog_default_value ();

      //@}

      /**
       * @name defaultHeight
       *
       * @brief Accessor and modifier functions for the %defaultHeight
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt DefaultHeightType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< DefaultHeightType, char > DefaultHeightTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const DefaultHeightType&
      defaultHeight () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      DefaultHeightType&
      defaultHeight ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      defaultHeight (const DefaultHeightType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static DefaultHeightType
      defaultHeight_default_value ();

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      MultiTextBox (const RefIdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      MultiTextBox (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      MultiTextBox (const MultiTextBox& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual MultiTextBox*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      MultiTextBox&
      operator= (const MultiTextBox& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~MultiTextBox ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< ShowAsDialogType > showAsDialog_;
      ::xsd::cxx::tree::one< DefaultHeightType > defaultHeight_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %CheckBox schema type.
     *
     * Represents a checkbox display element.
     *
     * @nosubgrouping
     */
    class CheckBox: public ::GroupPolicy::PolicyDefinitions::DataElementContent
    {
      public:
      /**
       * @name defaultChecked
       *
       * @brief Accessor and modifier functions for the %defaultChecked
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean DefaultCheckedType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< DefaultCheckedType, char > DefaultCheckedTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const DefaultCheckedType&
      defaultChecked () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      DefaultCheckedType&
      defaultChecked ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      defaultChecked (const DefaultCheckedType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static DefaultCheckedType
      defaultChecked_default_value ();

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from initializers for required 
       * elements and attributes.
       */
      CheckBox (const RefIdType&);

      /**
       * @brief Create an instance from a C string and initializers
       * for required elements and attributes.
       */
      CheckBox (const char*,
                const RefIdType&);

      /**
       * @brief Create an instance from a string andinitializers
       * for required elements and attributes.
       */
      CheckBox (const ::std::string&,
                const RefIdType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      CheckBox (const ::xml_schema::String&,
                const RefIdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      CheckBox (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      CheckBox (const CheckBox& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual CheckBox*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      CheckBox&
      operator= (const CheckBox& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~CheckBox ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< DefaultCheckedType > defaultChecked_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ComboBox schema type.
     *
     * Represents a combobox display element with default/suggested entries.
     *
     * @nosubgrouping
     */
    class ComboBox: public ::GroupPolicy::PolicyDefinitions::DataElement
    {
      public:
      /**
       * @name label
       *
       * @brief Accessor and modifier functions for the %label
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String LabelType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< LabelType, char > LabelTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const LabelType&
      label () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      LabelType&
      label ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      label (const LabelType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      label (::std::unique_ptr< LabelType > p);

      //@}

      /**
       * @name default
       *
       * @brief Accessor and modifier functions for the %default
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String DefaultType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< DefaultType > DefaultOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< DefaultType, char > DefaultTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const DefaultOptional&
      default_ () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      DefaultOptional&
      default_ ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      default_ (const DefaultType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      default_ (const DefaultOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      default_ (::std::unique_ptr< DefaultType > p);

      //@}

      /**
       * @name suggestion
       *
       * @brief Accessor and modifier functions for the %suggestion
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String SuggestionType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< SuggestionType > SuggestionSequence;

      /**
       * @brief Element iterator type.
       */
      typedef SuggestionSequence::iterator SuggestionIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef SuggestionSequence::const_iterator SuggestionConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< SuggestionType, char > SuggestionTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const SuggestionSequence&
      suggestion () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      SuggestionSequence&
      suggestion ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      suggestion (const SuggestionSequence& s);

      //@}

      /**
       * @name noSort
       *
       * @brief Accessor and modifier functions for the %noSort
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean NoSortType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< NoSortType, char > NoSortTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const NoSortType&
      noSort () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      NoSortType&
      noSort ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      noSort (const NoSortType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static NoSortType
      noSort_default_value ();

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ComboBox (const RefIdType&,
                const LabelType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      ComboBox (const RefIdType&,
                ::std::unique_ptr< LabelType >);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ComboBox (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ComboBox (const ComboBox& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ComboBox*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ComboBox&
      operator= (const ComboBox& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ComboBox ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< LabelType > label_;
      DefaultOptional default__;
      SuggestionSequence suggestion_;
      ::xsd::cxx::tree::one< NoSortType > noSort_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %DropdownList schema type.
     *
     * Represents a dropdown list display element.
     *
     * @nosubgrouping
     */
    class DropdownList: public ::GroupPolicy::PolicyDefinitions::DataElementContent
    {
      public:
      /**
       * @name noSort
       *
       * @brief Accessor and modifier functions for the %noSort
       * optional attribute with a default value.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::Boolean NoSortType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< NoSortType, char > NoSortTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const NoSortType&
      noSort () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      NoSortType&
      noSort ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      noSort (const NoSortType& x);

      /**
       * @brief Return the default value for the attribute.
       *
       * @return The attribute's default value.
       */
      static NoSortType
      noSort_default_value ();

      //@}

      /**
       * @name defaultItem
       *
       * @brief Accessor and modifier functions for the %defaultItem
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt DefaultItemType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< DefaultItemType > DefaultItemOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< DefaultItemType, char > DefaultItemTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const DefaultItemOptional&
      defaultItem () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      DefaultItemOptional&
      defaultItem ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      defaultItem (const DefaultItemType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      defaultItem (const DefaultItemOptional& x);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from initializers for required 
       * elements and attributes.
       */
      DropdownList (const RefIdType&);

      /**
       * @brief Create an instance from a C string and initializers
       * for required elements and attributes.
       */
      DropdownList (const char*,
                    const RefIdType&);

      /**
       * @brief Create an instance from a string andinitializers
       * for required elements and attributes.
       */
      DropdownList (const ::std::string&,
                    const RefIdType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      DropdownList (const ::xml_schema::String&,
                    const RefIdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      DropdownList (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DropdownList (const DropdownList& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual DropdownList*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      DropdownList&
      operator= (const DropdownList& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~DropdownList ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< NoSortType > noSort_;
      DefaultItemOptional defaultItem_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ListBox schema type.
     *
     * Represents a listbox display element.
     *
     * @nosubgrouping
     */
    class ListBox: public ::GroupPolicy::PolicyDefinitions::DataElementContent
    {
      public:
      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from initializers for required 
       * elements and attributes.
       */
      ListBox (const RefIdType&);

      /**
       * @brief Create an instance from a C string and initializers
       * for required elements and attributes.
       */
      ListBox (const char*,
               const RefIdType&);

      /**
       * @brief Create an instance from a string andinitializers
       * for required elements and attributes.
       */
      ListBox (const ::std::string&,
               const RefIdType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ListBox (const ::xml_schema::String&,
               const RefIdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ListBox (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ListBox (const ListBox& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ListBox*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ListBox ();
    };

    /**
     * @brief Class corresponding to the %PolicyPresentation schema type.
     *
     * @nosubgrouping
     */
    class PolicyPresentation: public ::xml_schema::Type
    {
      public:
      /**
       * @name text
       *
       * @brief Accessor and modifier functions for the %text
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String TextType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< TextType > TextSequence;

      /**
       * @brief Element iterator type.
       */
      typedef TextSequence::iterator TextIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef TextSequence::const_iterator TextConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TextType, char > TextTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const TextSequence&
      text () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      TextSequence&
      text ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      text (const TextSequence& s);

      //@}

      /**
       * @name decimalTextBox
       *
       * @brief Accessor and modifier functions for the %decimalTextBox
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::DecimalTextBox DecimalTextBoxType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< DecimalTextBoxType > DecimalTextBoxSequence;

      /**
       * @brief Element iterator type.
       */
      typedef DecimalTextBoxSequence::iterator DecimalTextBoxIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef DecimalTextBoxSequence::const_iterator DecimalTextBoxConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< DecimalTextBoxType, char > DecimalTextBoxTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const DecimalTextBoxSequence&
      decimalTextBox () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      DecimalTextBoxSequence&
      decimalTextBox ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      decimalTextBox (const DecimalTextBoxSequence& s);

      //@}

      /**
       * @name textBox
       *
       * @brief Accessor and modifier functions for the %textBox
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::TextBox TextBoxType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< TextBoxType > TextBoxSequence;

      /**
       * @brief Element iterator type.
       */
      typedef TextBoxSequence::iterator TextBoxIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef TextBoxSequence::const_iterator TextBoxConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TextBoxType, char > TextBoxTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const TextBoxSequence&
      textBox () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      TextBoxSequence&
      textBox ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      textBox (const TextBoxSequence& s);

      //@}

      /**
       * @name checkBox
       *
       * @brief Accessor and modifier functions for the %checkBox
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::CheckBox CheckBoxType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< CheckBoxType > CheckBoxSequence;

      /**
       * @brief Element iterator type.
       */
      typedef CheckBoxSequence::iterator CheckBoxIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef CheckBoxSequence::const_iterator CheckBoxConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< CheckBoxType, char > CheckBoxTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const CheckBoxSequence&
      checkBox () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      CheckBoxSequence&
      checkBox ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      checkBox (const CheckBoxSequence& s);

      //@}

      /**
       * @name comboBox
       *
       * @brief Accessor and modifier functions for the %comboBox
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ComboBox ComboBoxType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ComboBoxType > ComboBoxSequence;

      /**
       * @brief Element iterator type.
       */
      typedef ComboBoxSequence::iterator ComboBoxIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ComboBoxSequence::const_iterator ComboBoxConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ComboBoxType, char > ComboBoxTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ComboBoxSequence&
      comboBox () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ComboBoxSequence&
      comboBox ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      comboBox (const ComboBoxSequence& s);

      //@}

      /**
       * @name dropdownList
       *
       * @brief Accessor and modifier functions for the %dropdownList
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::DropdownList DropdownListType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< DropdownListType > DropdownListSequence;

      /**
       * @brief Element iterator type.
       */
      typedef DropdownListSequence::iterator DropdownListIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef DropdownListSequence::const_iterator DropdownListConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< DropdownListType, char > DropdownListTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const DropdownListSequence&
      dropdownList () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      DropdownListSequence&
      dropdownList ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      dropdownList (const DropdownListSequence& s);

      //@}

      /**
       * @name listBox
       *
       * @brief Accessor and modifier functions for the %listBox
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ListBox ListBoxType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ListBoxType > ListBoxSequence;

      /**
       * @brief Element iterator type.
       */
      typedef ListBoxSequence::iterator ListBoxIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ListBoxSequence::const_iterator ListBoxConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ListBoxType, char > ListBoxTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ListBoxSequence&
      listBox () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ListBoxSequence&
      listBox ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      listBox (const ListBoxSequence& s);

      //@}

      /**
       * @name longDecimalTextBox
       *
       * @brief Accessor and modifier functions for the %longDecimalTextBox
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::LongDecimalTextBox LongDecimalTextBoxType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< LongDecimalTextBoxType > LongDecimalTextBoxSequence;

      /**
       * @brief Element iterator type.
       */
      typedef LongDecimalTextBoxSequence::iterator LongDecimalTextBoxIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef LongDecimalTextBoxSequence::const_iterator LongDecimalTextBoxConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< LongDecimalTextBoxType, char > LongDecimalTextBoxTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const LongDecimalTextBoxSequence&
      longDecimalTextBox () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      LongDecimalTextBoxSequence&
      longDecimalTextBox ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      longDecimalTextBox (const LongDecimalTextBoxSequence& s);

      //@}

      /**
       * @name multiTextBox
       *
       * @brief Accessor and modifier functions for the %multiTextBox
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::MultiTextBox MultiTextBoxType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< MultiTextBoxType > MultiTextBoxSequence;

      /**
       * @brief Element iterator type.
       */
      typedef MultiTextBoxSequence::iterator MultiTextBoxIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef MultiTextBoxSequence::const_iterator MultiTextBoxConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< MultiTextBoxType, char > MultiTextBoxTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const MultiTextBoxSequence&
      multiTextBox () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      MultiTextBoxSequence&
      multiTextBox ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      multiTextBox (const MultiTextBoxSequence& s);

      //@}

      /**
       * @name id
       *
       * @brief Accessor and modifier functions for the %id
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ResourceID IdType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const IdType&
      id () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      IdType&
      id ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      id (const IdType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      id (::std::unique_ptr< IdType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      PolicyPresentation (const IdType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      PolicyPresentation (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      PolicyPresentation (const PolicyPresentation& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual PolicyPresentation*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      PolicyPresentation&
      operator= (const PolicyPresentation& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~PolicyPresentation ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      TextSequence text_;
      DecimalTextBoxSequence decimalTextBox_;
      TextBoxSequence textBox_;
      CheckBoxSequence checkBox_;
      ComboBoxSequence comboBox_;
      DropdownListSequence dropdownList_;
      ListBoxSequence listBox_;
      LongDecimalTextBoxSequence longDecimalTextBox_;
      MultiTextBoxSequence multiTextBox_;
      ::xsd::cxx::tree::one< IdType > id_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %CategoryReference schema type.
     *
     * A reference to an already defined category.
     *
     * @nosubgrouping
     */
    class CategoryReference: public ::xml_schema::Type
    {
      public:
      /**
       * @name ref
       *
       * @brief Accessor and modifier functions for the %ref
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ItemReference RefType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const RefType&
      ref () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      RefType&
      ref ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      ref (const RefType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      ref (::std::unique_ptr< RefType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      CategoryReference (const RefType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      CategoryReference (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      CategoryReference (const CategoryReference& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual CategoryReference*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      CategoryReference&
      operator= (const CategoryReference& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~CategoryReference ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< RefType > ref_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %Category schema type.
     *
     * A grouping of policy definitions.
     *
     * @nosubgrouping
     */
    class Category: public ::xml_schema::Type
    {
      public:
      /**
       * @name annotation
       *
       * @brief Accessor and modifier functions for the %annotation
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::Annotation AnnotationType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< AnnotationType > AnnotationSequence;

      /**
       * @brief Element iterator type.
       */
      typedef AnnotationSequence::iterator AnnotationIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef AnnotationSequence::const_iterator AnnotationConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const AnnotationSequence&
      annotation () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      AnnotationSequence&
      annotation ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      annotation (const AnnotationSequence& s);

      //@}

      /**
       * @name parentCategory
       *
       * @brief Accessor and modifier functions for the %parentCategory
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::CategoryReference ParentCategoryType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ParentCategoryType > ParentCategoryOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ParentCategoryType, char > ParentCategoryTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ParentCategoryOptional&
      parentCategory () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ParentCategoryOptional&
      parentCategory ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      parentCategory (const ParentCategoryType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      parentCategory (const ParentCategoryOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      parentCategory (::std::unique_ptr< ParentCategoryType > p);

      //@}

      /**
       * @name seeAlso
       *
       * @brief Accessor and modifier functions for the %seeAlso
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String SeeAlsoType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< SeeAlsoType > SeeAlsoSequence;

      /**
       * @brief Element iterator type.
       */
      typedef SeeAlsoSequence::iterator SeeAlsoIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef SeeAlsoSequence::const_iterator SeeAlsoConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< SeeAlsoType, char > SeeAlsoTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const SeeAlsoSequence&
      seeAlso () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      SeeAlsoSequence&
      seeAlso ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      seeAlso (const SeeAlsoSequence& s);

      //@}

      /**
       * @name keywords
       *
       * @brief Accessor and modifier functions for the %keywords
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String KeywordsType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< KeywordsType > KeywordsOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< KeywordsType, char > KeywordsTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const KeywordsOptional&
      keywords () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      KeywordsOptional&
      keywords ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      keywords (const KeywordsType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      keywords (const KeywordsOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      keywords (::std::unique_ptr< KeywordsType > p);

      //@}

      /**
       * @name name
       *
       * @brief Accessor and modifier functions for the %name
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ItemName NameType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const NameType&
      name () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      NameType&
      name ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      name (const NameType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      name (::std::unique_ptr< NameType > p);

      //@}

      /**
       * @name displayName
       *
       * @brief Accessor and modifier functions for the %displayName
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::StringReference DisplayNameType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< DisplayNameType, char > DisplayNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const DisplayNameType&
      displayName () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      DisplayNameType&
      displayName ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      displayName (const DisplayNameType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      displayName (::std::unique_ptr< DisplayNameType > p);

      //@}

      /**
       * @name explainText
       *
       * @brief Accessor and modifier functions for the %explainText
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::StringReference ExplainTextType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ExplainTextType > ExplainTextOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ExplainTextType, char > ExplainTextTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ExplainTextOptional&
      explainText () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ExplainTextOptional&
      explainText ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      explainText (const ExplainTextType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      explainText (const ExplainTextOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      explainText (::std::unique_ptr< ExplainTextType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      Category (const NameType&,
                const DisplayNameType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      Category (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Category (const Category& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual Category*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Category&
      operator= (const Category& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~Category ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      AnnotationSequence annotation_;
      ParentCategoryOptional parentCategory_;
      SeeAlsoSequence seeAlso_;
      KeywordsOptional keywords_;
      ::xsd::cxx::tree::one< NameType > name_;
      ::xsd::cxx::tree::one< DisplayNameType > displayName_;
      ExplainTextOptional explainText_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %SupportedProducts schema type.
     *
     * A table of potentially supported products.
     *
     * @nosubgrouping
     */
    class SupportedProducts: public ::xml_schema::Type
    {
      public:
      /**
       * @name product
       *
       * @brief Accessor and modifier functions for the %product
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::SupportedProduct ProductType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ProductType > ProductSequence;

      /**
       * @brief Element iterator type.
       */
      typedef ProductSequence::iterator ProductIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ProductSequence::const_iterator ProductConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ProductType, char > ProductTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ProductSequence&
      product () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ProductSequence&
      product ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      product (const ProductSequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SupportedProducts ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SupportedProducts (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedProducts (const SupportedProducts& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SupportedProducts*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedProducts&
      operator= (const SupportedProducts& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SupportedProducts ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ProductSequence product_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %SupportedProduct schema type.
     *
     * A potentially supported product that can be referenced by a policy as
     * being supported on.
     *
     * @nosubgrouping
     */
    class SupportedProduct: public ::xml_schema::Type
    {
      public:
      /**
       * @name majorVersion
       *
       * @brief Accessor and modifier functions for the %majorVersion
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::SupportedMajorVersion MajorVersionType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< MajorVersionType > MajorVersionSequence;

      /**
       * @brief Element iterator type.
       */
      typedef MajorVersionSequence::iterator MajorVersionIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef MajorVersionSequence::const_iterator MajorVersionConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< MajorVersionType, char > MajorVersionTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const MajorVersionSequence&
      majorVersion () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      MajorVersionSequence&
      majorVersion ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      majorVersion (const MajorVersionSequence& s);

      //@}

      /**
       * @name name
       *
       * @brief Accessor and modifier functions for the %name
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ItemName NameType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const NameType&
      name () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      NameType&
      name ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      name (const NameType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      name (::std::unique_ptr< NameType > p);

      //@}

      /**
       * @name displayName
       *
       * @brief Accessor and modifier functions for the %displayName
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::StringReference DisplayNameType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< DisplayNameType, char > DisplayNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const DisplayNameType&
      displayName () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      DisplayNameType&
      displayName ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      displayName (const DisplayNameType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      displayName (::std::unique_ptr< DisplayNameType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SupportedProduct (const NameType&,
                        const DisplayNameType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SupportedProduct (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedProduct (const SupportedProduct& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SupportedProduct*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedProduct&
      operator= (const SupportedProduct& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SupportedProduct ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      MajorVersionSequence majorVersion_;
      ::xsd::cxx::tree::one< NameType > name_;
      ::xsd::cxx::tree::one< DisplayNameType > displayName_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %SupportedMajorVersion schema type.
     *
     * A major version of a product that can be referenced by a policy as
     * being supported on.
     *
     * @nosubgrouping
     */
    class SupportedMajorVersion: public ::xml_schema::Type
    {
      public:
      /**
       * @name minorVersion
       *
       * @brief Accessor and modifier functions for the %minorVersion
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::SupportedMinorVersion MinorVersionType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< MinorVersionType > MinorVersionSequence;

      /**
       * @brief Element iterator type.
       */
      typedef MinorVersionSequence::iterator MinorVersionIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef MinorVersionSequence::const_iterator MinorVersionConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< MinorVersionType, char > MinorVersionTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const MinorVersionSequence&
      minorVersion () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      MinorVersionSequence&
      minorVersion ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      minorVersion (const MinorVersionSequence& s);

      //@}

      /**
       * @name name
       *
       * @brief Accessor and modifier functions for the %name
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ItemName NameType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const NameType&
      name () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      NameType&
      name ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      name (const NameType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      name (::std::unique_ptr< NameType > p);

      //@}

      /**
       * @name displayName
       *
       * @brief Accessor and modifier functions for the %displayName
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::StringReference DisplayNameType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< DisplayNameType, char > DisplayNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const DisplayNameType&
      displayName () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      DisplayNameType&
      displayName ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      displayName (const DisplayNameType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      displayName (::std::unique_ptr< DisplayNameType > p);

      //@}

      /**
       * @name versionIndex
       *
       * @brief Accessor and modifier functions for the %versionIndex
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt VersionIndexType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< VersionIndexType, char > VersionIndexTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const VersionIndexType&
      versionIndex () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      VersionIndexType&
      versionIndex ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      versionIndex (const VersionIndexType& x);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SupportedMajorVersion (const NameType&,
                             const DisplayNameType&,
                             const VersionIndexType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SupportedMajorVersion (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedMajorVersion (const SupportedMajorVersion& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SupportedMajorVersion*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedMajorVersion&
      operator= (const SupportedMajorVersion& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SupportedMajorVersion ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      MinorVersionSequence minorVersion_;
      ::xsd::cxx::tree::one< NameType > name_;
      ::xsd::cxx::tree::one< DisplayNameType > displayName_;
      ::xsd::cxx::tree::one< VersionIndexType > versionIndex_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %SupportedMinorVersion schema type.
     *
     * Single version of a component to facilitate simple ranking of versions
     *
     * @nosubgrouping
     */
    class SupportedMinorVersion: public ::xml_schema::Type
    {
      public:
      /**
       * @name displayName
       *
       * @brief Accessor and modifier functions for the %displayName
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::StringReference DisplayNameType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< DisplayNameType, char > DisplayNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const DisplayNameType&
      displayName () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      DisplayNameType&
      displayName ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      displayName (const DisplayNameType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      displayName (::std::unique_ptr< DisplayNameType > p);

      //@}

      /**
       * @name name
       *
       * @brief Accessor and modifier functions for the %name
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ItemName NameType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const NameType&
      name () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      NameType&
      name ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      name (const NameType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      name (::std::unique_ptr< NameType > p);

      //@}

      /**
       * @name versionIndex
       *
       * @brief Accessor and modifier functions for the %versionIndex
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt VersionIndexType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< VersionIndexType, char > VersionIndexTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const VersionIndexType&
      versionIndex () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      VersionIndexType&
      versionIndex ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      versionIndex (const VersionIndexType& x);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SupportedMinorVersion (const DisplayNameType&,
                             const NameType&,
                             const VersionIndexType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SupportedMinorVersion (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedMinorVersion (const SupportedMinorVersion& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SupportedMinorVersion*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedMinorVersion&
      operator= (const SupportedMinorVersion& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SupportedMinorVersion ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< DisplayNameType > displayName_;
      ::xsd::cxx::tree::one< NameType > name_;
      ::xsd::cxx::tree::one< VersionIndexType > versionIndex_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %SupportedOnReference schema type.
     *
     * Reference to a supported product definition (single version or complex
     * definition).
     *
     * @nosubgrouping
     */
    class SupportedOnReference: public ::xml_schema::Type
    {
      public:
      /**
       * @name ref
       *
       * @brief Accessor and modifier functions for the %ref
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ItemReference RefType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const RefType&
      ref () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      RefType&
      ref ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      ref (const RefType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      ref (::std::unique_ptr< RefType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SupportedOnReference (const RefType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SupportedOnReference (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedOnReference (const SupportedOnReference& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SupportedOnReference*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedOnReference&
      operator= (const SupportedOnReference& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SupportedOnReference ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< RefType > ref_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %SupportedOnRange schema type.
     *
     * Supported version range.
     *
     * @nosubgrouping
     */
    class SupportedOnRange: public ::xml_schema::Type
    {
      public:
      /**
       * @name ref
       *
       * @brief Accessor and modifier functions for the %ref
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ItemReference RefType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< RefType, char > RefTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const RefType&
      ref () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      RefType&
      ref ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      ref (const RefType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      ref (::std::unique_ptr< RefType > p);

      //@}

      /**
       * @name minVersionIndex
       *
       * @brief Accessor and modifier functions for the %minVersionIndex
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt MinVersionIndexType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< MinVersionIndexType > MinVersionIndexOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< MinVersionIndexType, char > MinVersionIndexTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const MinVersionIndexOptional&
      minVersionIndex () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      MinVersionIndexOptional&
      minVersionIndex ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      minVersionIndex (const MinVersionIndexType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      minVersionIndex (const MinVersionIndexOptional& x);

      //@}

      /**
       * @name maxVersionIndex
       *
       * @brief Accessor and modifier functions for the %maxVersionIndex
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt MaxVersionIndexType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< MaxVersionIndexType > MaxVersionIndexOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< MaxVersionIndexType, char > MaxVersionIndexTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const MaxVersionIndexOptional&
      maxVersionIndex () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      MaxVersionIndexOptional&
      maxVersionIndex ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      maxVersionIndex (const MaxVersionIndexType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      maxVersionIndex (const MaxVersionIndexOptional& x);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SupportedOnRange (const RefType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SupportedOnRange (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedOnRange (const SupportedOnRange& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SupportedOnRange*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedOnRange&
      operator= (const SupportedOnRange& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SupportedOnRange ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< RefType > ref_;
      MinVersionIndexOptional minVersionIndex_;
      MaxVersionIndexOptional maxVersionIndex_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %SupportedAndCondition schema type.
     *
     * A group of supported components that must all be true for the policy
     * definition to be supported.
     *
     * @nosubgrouping
     */
    class SupportedAndCondition: public ::xml_schema::Type
    {
      public:
      /**
       * @name range
       *
       * @brief Accessor and modifier functions for the %range
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::SupportedOnRange RangeType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< RangeType > RangeSequence;

      /**
       * @brief Element iterator type.
       */
      typedef RangeSequence::iterator RangeIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef RangeSequence::const_iterator RangeConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< RangeType, char > RangeTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const RangeSequence&
      range () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      RangeSequence&
      range ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      range (const RangeSequence& s);

      //@}

      /**
       * @name reference
       *
       * @brief Accessor and modifier functions for the %reference
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::SupportedOnReference ReferenceType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ReferenceType > ReferenceSequence;

      /**
       * @brief Element iterator type.
       */
      typedef ReferenceSequence::iterator ReferenceIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ReferenceSequence::const_iterator ReferenceConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ReferenceType, char > ReferenceTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ReferenceSequence&
      reference () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ReferenceSequence&
      reference ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      reference (const ReferenceSequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SupportedAndCondition ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SupportedAndCondition (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedAndCondition (const SupportedAndCondition& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SupportedAndCondition*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedAndCondition&
      operator= (const SupportedAndCondition& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SupportedAndCondition ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      RangeSequence range_;
      ReferenceSequence reference_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %SupportedOrCondition schema type.
     *
     * A group of supported components where at least one must be true for
     * the policy definition to be supported.
     *
     * @nosubgrouping
     */
    class SupportedOrCondition: public ::xml_schema::Type
    {
      public:
      /**
       * @name range
       *
       * @brief Accessor and modifier functions for the %range
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::SupportedOnRange RangeType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< RangeType > RangeSequence;

      /**
       * @brief Element iterator type.
       */
      typedef RangeSequence::iterator RangeIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef RangeSequence::const_iterator RangeConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< RangeType, char > RangeTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const RangeSequence&
      range () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      RangeSequence&
      range ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      range (const RangeSequence& s);

      //@}

      /**
       * @name reference
       *
       * @brief Accessor and modifier functions for the %reference
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::SupportedOnReference ReferenceType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ReferenceType > ReferenceSequence;

      /**
       * @brief Element iterator type.
       */
      typedef ReferenceSequence::iterator ReferenceIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ReferenceSequence::const_iterator ReferenceConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ReferenceType, char > ReferenceTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ReferenceSequence&
      reference () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ReferenceSequence&
      reference ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      reference (const ReferenceSequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SupportedOrCondition ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SupportedOrCondition (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedOrCondition (const SupportedOrCondition& x,
                            ::xml_schema::Flags f = 0,
                            ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SupportedOrCondition*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedOrCondition&
      operator= (const SupportedOrCondition& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SupportedOrCondition ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      RangeSequence range_;
      ReferenceSequence reference_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %SupportedOnDefinition schema type.
     *
     * Definition of complex supported product major and/or minor versions,
     * etc.
     * The DisplayName must be a linguistic representation of the complex
     * supported-on definition.
     *
     * @nosubgrouping
     */
    class SupportedOnDefinition: public ::xml_schema::Type
    {
      public:
      /**
       * @name or
       *
       * @brief Accessor and modifier functions for the %or
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::SupportedOrCondition OrType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< OrType > OrOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< OrType, char > OrTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const OrOptional&
      or_ () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      OrOptional&
      or_ ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      or_ (const OrType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      or_ (const OrOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      or_ (::std::unique_ptr< OrType > p);

      //@}

      /**
       * @name and
       *
       * @brief Accessor and modifier functions for the %and
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::SupportedAndCondition AndType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< AndType > AndOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< AndType, char > AndTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const AndOptional&
      and_ () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      AndOptional&
      and_ ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      and_ (const AndType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      and_ (const AndOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      and_ (::std::unique_ptr< AndType > p);

      //@}

      /**
       * @name name
       *
       * @brief Accessor and modifier functions for the %name
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ItemName NameType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const NameType&
      name () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      NameType&
      name ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      name (const NameType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      name (::std::unique_ptr< NameType > p);

      //@}

      /**
       * @name displayName
       *
       * @brief Accessor and modifier functions for the %displayName
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::StringReference DisplayNameType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< DisplayNameType, char > DisplayNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const DisplayNameType&
      displayName () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      DisplayNameType&
      displayName ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      displayName (const DisplayNameType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      displayName (::std::unique_ptr< DisplayNameType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SupportedOnDefinition (const NameType&,
                             const DisplayNameType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SupportedOnDefinition (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedOnDefinition (const SupportedOnDefinition& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SupportedOnDefinition*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedOnDefinition&
      operator= (const SupportedOnDefinition& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SupportedOnDefinition ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      OrOptional or__;
      AndOptional and__;
      ::xsd::cxx::tree::one< NameType > name_;
      ::xsd::cxx::tree::one< DisplayNameType > displayName_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %SupportedOnDefinitions schema type.
     *
     * Table of supported components definitions.
     *
     * @nosubgrouping
     */
    class SupportedOnDefinitions: public ::xml_schema::Type
    {
      public:
      /**
       * @name definition
       *
       * @brief Accessor and modifier functions for the %definition
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::SupportedOnDefinition DefinitionType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< DefinitionType > DefinitionSequence;

      /**
       * @brief Element iterator type.
       */
      typedef DefinitionSequence::iterator DefinitionIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef DefinitionSequence::const_iterator DefinitionConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< DefinitionType, char > DefinitionTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const DefinitionSequence&
      definition () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      DefinitionSequence&
      definition ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      definition (const DefinitionSequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      SupportedOnDefinitions ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      SupportedOnDefinitions (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedOnDefinitions (const SupportedOnDefinitions& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual SupportedOnDefinitions*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      SupportedOnDefinitions&
      operator= (const SupportedOnDefinitions& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~SupportedOnDefinitions ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      DefinitionSequence definition_;

      //@endcond
    };

    /**
     * @brief Enumeration class corresponding to the %PolicyClass
     * schema type.
     *
     * An enumeration of the 3 possible classes a policy definition can
     * belong to.
     */
    class PolicyClass: public ::xml_schema::Token
    {
      public:

      /**
       * @brief Underlying enum type.
       */
      enum Value
      {
        User,
        Machine,
        Both
      };

      /**
       * @brief Create an instance from the underlying enum value.
       *
       * @param v A enum value.
       */
      PolicyClass (Value v);

      /**
       * @brief Create an instance from a C string.
       *
       * @param v A string value.
       */
      PolicyClass (const char* v);

      /**
       * @brief Create an instance from a string.
       *
       * @param v A string value.
       */
      PolicyClass (const ::std::string& v);

      /**
       * @brief Create an instance from the base value.
       *
       * @param v A base value.
       */
      PolicyClass (const ::xml_schema::Token& v);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      PolicyClass (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      PolicyClass (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      PolicyClass (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      PolicyClass (const PolicyClass& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual PolicyClass*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Assign the underlying enum value.
       *
       * @param v A enum value.
       * @return A refernce to the instance.
       */
      PolicyClass&
      operator= (Value v);

      /**
       * @brief Implicit conversion operator to the underlying
       * enum value.
       *
       * @return A enum value.
       */
      virtual
      operator Value () const
      {
        return _xsd_PolicyClass_convert ();
      }

      //@cond

      protected:
      Value
      _xsd_PolicyClass_convert () const;

      public:
      static const char* const _xsd_PolicyClass_literals_[3];
      static const Value _xsd_PolicyClass_indexes_[3];

      //@endcond
    };

    /**
     * @brief Class corresponding to the %PolicyDefinition schema type.
     *
     * @nosubgrouping
     */
    class PolicyDefinition: public ::xml_schema::Type
    {
      public:
      /**
       * @name annotation
       *
       * @brief Accessor and modifier functions for the %annotation
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::Annotation AnnotationType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< AnnotationType > AnnotationSequence;

      /**
       * @brief Element iterator type.
       */
      typedef AnnotationSequence::iterator AnnotationIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef AnnotationSequence::const_iterator AnnotationConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const AnnotationSequence&
      annotation () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      AnnotationSequence&
      annotation ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      annotation (const AnnotationSequence& s);

      //@}

      /**
       * @name parentCategory
       *
       * @brief Accessor and modifier functions for the %parentCategory
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::CategoryReference ParentCategoryType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ParentCategoryType > ParentCategoryOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ParentCategoryType, char > ParentCategoryTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ParentCategoryOptional&
      parentCategory () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ParentCategoryOptional&
      parentCategory ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      parentCategory (const ParentCategoryType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      parentCategory (const ParentCategoryOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      parentCategory (::std::unique_ptr< ParentCategoryType > p);

      //@}

      /**
       * @name seeAlso
       *
       * @brief Accessor and modifier functions for the %seeAlso
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String SeeAlsoType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< SeeAlsoType > SeeAlsoSequence;

      /**
       * @brief Element iterator type.
       */
      typedef SeeAlsoSequence::iterator SeeAlsoIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef SeeAlsoSequence::const_iterator SeeAlsoConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< SeeAlsoType, char > SeeAlsoTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const SeeAlsoSequence&
      seeAlso () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      SeeAlsoSequence&
      seeAlso ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      seeAlso (const SeeAlsoSequence& s);

      //@}

      /**
       * @name keywords
       *
       * @brief Accessor and modifier functions for the %keywords
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::String KeywordsType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< KeywordsType > KeywordsOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< KeywordsType, char > KeywordsTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const KeywordsOptional&
      keywords () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      KeywordsOptional&
      keywords ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      keywords (const KeywordsType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      keywords (const KeywordsOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      keywords (::std::unique_ptr< KeywordsType > p);

      //@}

      /**
       * @name supportedOn
       *
       * @brief Accessor and modifier functions for the %supportedOn
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::SupportedOnReference SupportedOnType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< SupportedOnType, char > SupportedOnTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const SupportedOnType&
      supportedOn () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      SupportedOnType&
      supportedOn ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      supportedOn (const SupportedOnType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      supportedOn (::std::unique_ptr< SupportedOnType > p);

      //@}

      /**
       * @name enabledValue
       *
       * @brief Accessor and modifier functions for the %enabledValue
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::Value EnabledValueType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< EnabledValueType > EnabledValueOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< EnabledValueType, char > EnabledValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const EnabledValueOptional&
      enabledValue () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      EnabledValueOptional&
      enabledValue ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      enabledValue (const EnabledValueType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      enabledValue (const EnabledValueOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      enabledValue (::std::unique_ptr< EnabledValueType > p);

      //@}

      /**
       * @name disabledValue
       *
       * @brief Accessor and modifier functions for the %disabledValue
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::Value DisabledValueType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< DisabledValueType > DisabledValueOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< DisabledValueType, char > DisabledValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const DisabledValueOptional&
      disabledValue () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      DisabledValueOptional&
      disabledValue ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      disabledValue (const DisabledValueType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      disabledValue (const DisabledValueOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      disabledValue (::std::unique_ptr< DisabledValueType > p);

      //@}

      /**
       * @name enabledList
       *
       * @brief Accessor and modifier functions for the %enabledList
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ValueList EnabledListType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< EnabledListType > EnabledListOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< EnabledListType, char > EnabledListTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const EnabledListOptional&
      enabledList () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      EnabledListOptional&
      enabledList ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      enabledList (const EnabledListType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      enabledList (const EnabledListOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      enabledList (::std::unique_ptr< EnabledListType > p);

      //@}

      /**
       * @name disabledList
       *
       * @brief Accessor and modifier functions for the %disabledList
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ValueList DisabledListType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< DisabledListType > DisabledListOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< DisabledListType, char > DisabledListTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const DisabledListOptional&
      disabledList () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      DisabledListOptional&
      disabledList ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      disabledList (const DisabledListType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      disabledList (const DisabledListOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      disabledList (::std::unique_ptr< DisabledListType > p);

      //@}

      /**
       * @name elements
       *
       * @brief Accessor and modifier functions for the %elements
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::PolicyElements ElementsType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ElementsType > ElementsOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ElementsType, char > ElementsTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ElementsOptional&
      elements () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ElementsOptional&
      elements ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      elements (const ElementsType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      elements (const ElementsOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      elements (::std::unique_ptr< ElementsType > p);

      //@}

      /**
       * @name name
       *
       * @brief Accessor and modifier functions for the %name
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ItemName NameType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const NameType&
      name () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      NameType&
      name ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      name (const NameType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      name (::std::unique_ptr< NameType > p);

      //@}

      /**
       * @name class
       *
       * @brief Accessor and modifier functions for the %class
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::PolicyClass ClassType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ClassType, char > ClassTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const ClassType&
      class_ () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      ClassType&
      class_ ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      class_ (const ClassType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      class_ (::std::unique_ptr< ClassType > p);

      //@}

      /**
       * @name displayName
       *
       * @brief Accessor and modifier functions for the %displayName
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::StringReference DisplayNameType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< DisplayNameType, char > DisplayNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const DisplayNameType&
      displayName () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      DisplayNameType&
      displayName ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      displayName (const DisplayNameType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      displayName (::std::unique_ptr< DisplayNameType > p);

      //@}

      /**
       * @name explainText
       *
       * @brief Accessor and modifier functions for the %explainText
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::StringReference ExplainTextType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ExplainTextType > ExplainTextOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ExplainTextType, char > ExplainTextTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ExplainTextOptional&
      explainText () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ExplainTextOptional&
      explainText ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      explainText (const ExplainTextType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      explainText (const ExplainTextOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      explainText (::std::unique_ptr< ExplainTextType > p);

      //@}

      /**
       * @name presentation
       *
       * @brief Accessor and modifier functions for the %presentation
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::PresentationReference PresentationType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< PresentationType > PresentationOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< PresentationType, char > PresentationTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const PresentationOptional&
      presentation () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      PresentationOptional&
      presentation ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      presentation (const PresentationType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      presentation (const PresentationOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      presentation (::std::unique_ptr< PresentationType > p);

      //@}

      /**
       * @name key
       *
       * @brief Accessor and modifier functions for the %key
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryKey KeyType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< KeyType, char > KeyTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const KeyType&
      key () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      KeyType&
      key ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      key (const KeyType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      key (::std::unique_ptr< KeyType > p);

      //@}

      /**
       * @name valueName
       *
       * @brief Accessor and modifier functions for the %valueName
       * optional attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::RegistryValueName ValueNameType;

      /**
       * @brief Attribute optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ValueNameType > ValueNameOptional;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ValueNameType, char > ValueNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ValueNameOptional&
      valueName () const;

      /**
       * @brief Return a read-write reference to the attribute container.
       *
       * @return A reference to the optional container.
       */
      ValueNameOptional&
      valueName ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      valueName (const ValueNameType& x);

      /**
       * @brief Set the attribute value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the attribute.
       * Otherwise the attribute container is set the 'not present' state.
       */
      void
      valueName (const ValueNameOptional& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      valueName (::std::unique_ptr< ValueNameType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      PolicyDefinition (const SupportedOnType&,
                        const NameType&,
                        const ClassType&,
                        const DisplayNameType&,
                        const KeyType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      PolicyDefinition (::std::unique_ptr< SupportedOnType >,
                        const NameType&,
                        const ClassType&,
                        const DisplayNameType&,
                        const KeyType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      PolicyDefinition (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      PolicyDefinition (const PolicyDefinition& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual PolicyDefinition*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      PolicyDefinition&
      operator= (const PolicyDefinition& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~PolicyDefinition ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      AnnotationSequence annotation_;
      ParentCategoryOptional parentCategory_;
      SeeAlsoSequence seeAlso_;
      KeywordsOptional keywords_;
      ::xsd::cxx::tree::one< SupportedOnType > supportedOn_;
      EnabledValueOptional enabledValue_;
      DisabledValueOptional disabledValue_;
      EnabledListOptional enabledList_;
      DisabledListOptional disabledList_;
      ElementsOptional elements_;
      ::xsd::cxx::tree::one< NameType > name_;
      ::xsd::cxx::tree::one< ClassType > class__;
      ::xsd::cxx::tree::one< DisplayNameType > displayName_;
      ExplainTextOptional explainText_;
      PresentationOptional presentation_;
      ::xsd::cxx::tree::one< KeyType > key_;
      ValueNameOptional valueName_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %PolicyElements schema type.
     *
     * @nosubgrouping
     */
    class PolicyElements: public ::xml_schema::Type
    {
      public:
      /**
       * @name boolean
       *
       * @brief Accessor and modifier functions for the %boolean
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::BooleanElement BooleanType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< BooleanType > BooleanSequence;

      /**
       * @brief Element iterator type.
       */
      typedef BooleanSequence::iterator BooleanIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef BooleanSequence::const_iterator BooleanConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< BooleanType, char > BooleanTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const BooleanSequence&
      boolean () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      BooleanSequence&
      boolean ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      boolean (const BooleanSequence& s);

      //@}

      /**
       * @name decimal
       *
       * @brief Accessor and modifier functions for the %decimal
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::DecimalElement DecimalType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< DecimalType > DecimalSequence;

      /**
       * @brief Element iterator type.
       */
      typedef DecimalSequence::iterator DecimalIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef DecimalSequence::const_iterator DecimalConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< DecimalType, char > DecimalTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const DecimalSequence&
      decimal () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      DecimalSequence&
      decimal ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      decimal (const DecimalSequence& s);

      //@}

      /**
       * @name text
       *
       * @brief Accessor and modifier functions for the %text
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::TextElement TextType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< TextType > TextSequence;

      /**
       * @brief Element iterator type.
       */
      typedef TextSequence::iterator TextIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef TextSequence::const_iterator TextConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< TextType, char > TextTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const TextSequence&
      text () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      TextSequence&
      text ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      text (const TextSequence& s);

      //@}

      /**
       * @name enum
       *
       * @brief Accessor and modifier functions for the %enum
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::EnumerationElement EnumType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< EnumType > EnumSequence;

      /**
       * @brief Element iterator type.
       */
      typedef EnumSequence::iterator EnumIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef EnumSequence::const_iterator EnumConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< EnumType, char > EnumTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const EnumSequence&
      enum_ () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      EnumSequence&
      enum_ ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      enum_ (const EnumSequence& s);

      //@}

      /**
       * @name list
       *
       * @brief Accessor and modifier functions for the %list
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ListElement ListType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ListType > ListSequence;

      /**
       * @brief Element iterator type.
       */
      typedef ListSequence::iterator ListIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ListSequence::const_iterator ListConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ListType, char > ListTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ListSequence&
      list () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ListSequence&
      list ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      list (const ListSequence& s);

      //@}

      /**
       * @name longDecimal
       *
       * @brief Accessor and modifier functions for the %longDecimal
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::LongDecimalElement LongDecimalType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< LongDecimalType > LongDecimalSequence;

      /**
       * @brief Element iterator type.
       */
      typedef LongDecimalSequence::iterator LongDecimalIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef LongDecimalSequence::const_iterator LongDecimalConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< LongDecimalType, char > LongDecimalTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const LongDecimalSequence&
      longDecimal () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      LongDecimalSequence&
      longDecimal ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      longDecimal (const LongDecimalSequence& s);

      //@}

      /**
       * @name multiText
       *
       * @brief Accessor and modifier functions for the %multiText
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::MultiTextElement MultiTextType;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< MultiTextType > MultiTextSequence;

      /**
       * @brief Element iterator type.
       */
      typedef MultiTextSequence::iterator MultiTextIterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef MultiTextSequence::const_iterator MultiTextConstIterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< MultiTextType, char > MultiTextTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const MultiTextSequence&
      multiText () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      MultiTextSequence&
      multiText ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      multiText (const MultiTextSequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      PolicyElements ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      PolicyElements (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      PolicyElements (const PolicyElements& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual PolicyElements*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      PolicyElements&
      operator= (const PolicyElements& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~PolicyElements ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      BooleanSequence boolean_;
      DecimalSequence decimal_;
      TextSequence text_;
      EnumSequence enum__;
      ListSequence list_;
      LongDecimalSequence longDecimal_;
      MultiTextSequence multiText_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %item schema type.
     *
     * @nosubgrouping
     */
    class Item: public ::xml_schema::Type
    {
      public:
      /**
       * @name value
       *
       * @brief Accessor and modifier functions for the %value
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::Value ValueType;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const ValueType&
      value () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      ValueType&
      value ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      value (const ValueType& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      value (::std::unique_ptr< ValueType > p);

      //@}

      /**
       * @name valueList
       *
       * @brief Accessor and modifier functions for the %valueList
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::ValueList ValueListType;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ValueListType > ValueListOptional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ValueListType, char > ValueListTraits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ValueListOptional&
      valueList () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ValueListOptional&
      valueList ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      valueList (const ValueListType& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      valueList (const ValueListOptional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      valueList (::std::unique_ptr< ValueListType > p);

      //@}

      /**
       * @name displayName
       *
       * @brief Accessor and modifier functions for the %displayName
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::GroupPolicy::PolicyDefinitions::StringReference DisplayNameType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< DisplayNameType, char > DisplayNameTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const DisplayNameType&
      displayName () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      DisplayNameType&
      displayName ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      displayName (const DisplayNameType& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      displayName (::std::unique_ptr< DisplayNameType > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      Item (const ValueType&,
            const DisplayNameType&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (::std::unique_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      Item (::std::unique_ptr< ValueType >,
            const DisplayNameType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      Item (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Item (const Item& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual Item*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Item&
      operator= (const Item& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~Item ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< ValueType > value_;
      ValueListOptional valueList_;
      ::xsd::cxx::tree::one< DisplayNameType > displayName_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %delete schema type.
     *
     * @nosubgrouping
     */
    class Delete: public ::xml_schema::Type
    {
      public:
      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      Delete ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      Delete (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      Delete (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      Delete (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Delete (const Delete& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual Delete*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~Delete ();
    };

    /**
     * @brief Class corresponding to the %decimal schema type.
     *
     * @nosubgrouping
     */
    class Decimal: public ::xml_schema::Type
    {
      public:
      /**
       * @name value
       *
       * @brief Accessor and modifier functions for the %value
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedInt ValueType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const ValueType&
      value () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      ValueType&
      value ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      value (const ValueType& x);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      Decimal (const ValueType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      Decimal (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Decimal (const Decimal& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual Decimal*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      Decimal&
      operator= (const Decimal& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~Decimal ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< ValueType > value_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %longDecimal schema type.
     *
     * @nosubgrouping
     */
    class LongDecimal: public ::xml_schema::Type
    {
      public:
      /**
       * @name value
       *
       * @brief Accessor and modifier functions for the %value
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::UnsignedLong ValueType;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const ValueType&
      value () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      ValueType&
      value ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      value (const ValueType& x);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      LongDecimal (const ValueType&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      LongDecimal (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      LongDecimal (const LongDecimal& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual LongDecimal*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      /**
       * @brief Copy assignment operator.
       *
       * @param x An instance to make a copy of.
       * @return A reference to itself.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      LongDecimal&
      operator= (const LongDecimal& x);

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~LongDecimal ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::Flags);

      protected:
      ::xsd::cxx::tree::one< ValueType > value_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %string schema type.
     *
     * @nosubgrouping
     */
    class String: public ::xml_schema::String
    {
      public:
      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from initializers for required 
       * elements and attributes.
       */
      String ();

      /**
       * @brief Create an instance from a C string and initializers
       * for required elements and attributes.
       */
      String (const char*);

      /**
       * @brief Create an instance from a string andinitializers
       * for required elements and attributes.
       */
      String (const ::std::string&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      String (const ::xml_schema::String&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      String (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a DOM attribute.
       *
       * @param a A DOM attribute to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      String (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      /**
       * @brief Create an instance from a string fragment.
       *
       * @param s A string fragment to extract the data from.
       * @param e A pointer to DOM element containing the string fragment.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      String (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      String (const String& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual String*
      _clone (::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~String ();
    };
  }
}

#include <iosfwd>

namespace GroupPolicy
{
  namespace PolicyDefinitions
  {
    ::std::ostream&
    operator<< (::std::ostream&, const DecimalElement&);

    ::std::ostream&
    operator<< (::std::ostream&, const LongDecimalElement&);

    ::std::ostream&
    operator<< (::std::ostream&, const BooleanElement&);

    ::std::ostream&
    operator<< (::std::ostream&, const TextElement&);

    ::std::ostream&
    operator<< (::std::ostream&, const EnumerationElement&);

    ::std::ostream&
    operator<< (::std::ostream&, const ListElement&);

    ::std::ostream&
    operator<< (::std::ostream&, const Value&);

    ::std::ostream&
    operator<< (::std::ostream&, const ValueList&);

    ::std::ostream&
    operator<< (::std::ostream&, const ValueItem&);

    ::std::ostream&
    operator<< (::std::ostream&, const MultiTextElement&);

    ::std::ostream&
    operator<< (::std::ostream&, const DataElementContent&);

    ::std::ostream&
    operator<< (::std::ostream&, const DataElement&);

    ::std::ostream&
    operator<< (::std::ostream&, const DecimalTextBox&);

    ::std::ostream&
    operator<< (::std::ostream&, const LongDecimalTextBox&);

    ::std::ostream&
    operator<< (::std::ostream&, const TextBox&);

    ::std::ostream&
    operator<< (::std::ostream&, const MultiTextBox&);

    ::std::ostream&
    operator<< (::std::ostream&, const CheckBox&);

    ::std::ostream&
    operator<< (::std::ostream&, const ComboBox&);

    ::std::ostream&
    operator<< (::std::ostream&, const DropdownList&);

    ::std::ostream&
    operator<< (::std::ostream&, const ListBox&);

    ::std::ostream&
    operator<< (::std::ostream&, const PolicyPresentation&);

    ::std::ostream&
    operator<< (::std::ostream&, const CategoryReference&);

    ::std::ostream&
    operator<< (::std::ostream&, const Category&);

    ::std::ostream&
    operator<< (::std::ostream&, const SupportedProducts&);

    ::std::ostream&
    operator<< (::std::ostream&, const SupportedProduct&);

    ::std::ostream&
    operator<< (::std::ostream&, const SupportedMajorVersion&);

    ::std::ostream&
    operator<< (::std::ostream&, const SupportedMinorVersion&);

    ::std::ostream&
    operator<< (::std::ostream&, const SupportedOnReference&);

    ::std::ostream&
    operator<< (::std::ostream&, const SupportedOnRange&);

    ::std::ostream&
    operator<< (::std::ostream&, const SupportedAndCondition&);

    ::std::ostream&
    operator<< (::std::ostream&, const SupportedOrCondition&);

    ::std::ostream&
    operator<< (::std::ostream&, const SupportedOnDefinition&);

    ::std::ostream&
    operator<< (::std::ostream&, const SupportedOnDefinitions&);

    ::std::ostream&
    operator<< (::std::ostream&, PolicyClass::Value);

    ::std::ostream&
    operator<< (::std::ostream&, const PolicyClass&);

    ::std::ostream&
    operator<< (::std::ostream&, const PolicyDefinition&);

    ::std::ostream&
    operator<< (::std::ostream&, const PolicyElements&);

    ::std::ostream&
    operator<< (::std::ostream&, const Item&);

    ::std::ostream&
    operator<< (::std::ostream&, const Delete&);

    ::std::ostream&
    operator<< (::std::ostream&, const Decimal&);

    ::std::ostream&
    operator<< (::std::ostream&, const LongDecimal&);

    ::std::ostream&
    operator<< (::std::ostream&, const String&);
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace GroupPolicy
{
  namespace PolicyDefinitions
  {
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // POLICY_DEFINITIONS_H
